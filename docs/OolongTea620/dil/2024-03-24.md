# 7장 : 분산 시스템을 위한 유일 ID 생성기

## 목적

분산시스템에서 사용될 유일 ID 생성기 설계

```
auto_increasement 속성이 설정된 관계형 데이터 베이스의 기본키를 사용하면 되지 않을까? 🤔 
```

**하지만...**
- 분산 환경에서 사용이 어려움
- 데이터베이스 서버 한대로 요구 감당이 어려움
- 여러 데이터베이스 서버를 사용하는 경우, 지연 시간을 낮추기가 무척 어려움

## ID생성기 설계 과정 

### 1단계 - 문제 이해 및 설계 범위 확정

책에서 가정하는 시스템 요구사항
```
- ID는 유일해야
- ID는 숫자로만 구성이 되어야 하고
- ID는 64비트로 표현될 수 있는 값이여야한다.
- ID는 발급 날짜에 따라 정렬 가능해야
- 초당 10,000개 정도의 ID를 만들 수 있어야한다.
```

### 2단계 - 개략적인 설계안 제시 및 동의 구하기

분산시스템에서 유일성이 보장되는 ID를 만드는 방법

```
- 다중 마스터 복제 (multi-master replication)
- UUID(Universally Unique Identifier)
- 티켓 서버(ticket server)
- 트위터 스노플레이크(twitter snowflake) 접근법
등..
```

#### 다중 마스터 복제(multi-master replication)

- 데이터베이스의 auto_increasement 활용
- 다음 ID의 값을 구할 때, 1만큼 증가가 아닌, `k`만큼 증가 시킨다 (`k` : 현재 사용 중인 데이터베이스 서버의 수)

중대한 **단점**
- 여러 데이터 센터에 걸쳐서 규모를 늘리기 어렵다.
- ID의 유일성은 보장되지만, 시간 흐름에 맞추어 커지도록 보장할 수 없다.
- 서버를 추가하거나 삭제 시, 잘 동작 되도록 만들기 어렵다.

#### UUID(Universally Unique Identifier)

컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 짜리 수

- 충돌 가능성이 지극히 낮다.
- 서버 간 조율 없이 독립적으로 생산 가능


**장점**

- UUID를 만들기 간단
- 서버 사이의 조율이 필요 없다 - 동기화 이슈
- 각 서버가 자신이 쓸 ID를 알아서 만드는 구조 - 쉬운 구조 확장


**단점**
(내 생각에는 이번 장 가정된 요구 사항을 조금 넘어서 그런 듯 하다)
- ID가 128비트로 길다.(이번 장에서 다루는 문제의 요구사항은 64비트) 
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자(numeric) 아닌 값이 포함 될 수 있다.

#### 티켓 서버(ticket server)

`플리커(Flickr)`는 분산 기본 키(distributed primary key)를 만들어 내가 위해 이 기술을 이용
```
auto_increasement 기능을 갖춘 데이터베이스 서버, 티켓 서버를 중앙 집중형으로 하나만 사용하는 것.
```

**장점**
- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합

**단점**
- 티켓 서버가 `SPOF(Single-Point-Of-Failure)`가 된다.
- 티켓 서버 장애 발생 시, 해당 서버를 이요하는 모든 시스템이 영향을 받는다.
  - 솔루션 : 티켓 서버를 여러대 준비해야 하지만, 추가적으로 동기화 이슈 발생이 가능하다.

#### `채택` 트위터 스노우플레이크(twitter snowflake) 접근법

트위터에서 사용하는 기술

책에서는 이 방법이 가장 요구사항에 적합한 케이스라고 설명 중

바로 ID를 생성하는 대신, 각개격파전략을 적용

**`각개격파전략(divide and conquer)`**

- 사인(sign)비트 : 1비트 할당. 음수와 양수를 구별하는데 사용 할 수 있음

- 타임스템프(timestamp) : 41비트 할당. 기원 시각(epoch)이후로 몇 밀리초가 경과했는지를 나타내는 값.

- 데이터센터 ID : 5비트 할당. 따라서 2^5 = 32개 서버를 사용할 수 있음

- 서버 ID : 5비트 할당. 따라서 데이터 센터 당 32개 서버를 사용할 수 있음

- 일련번호 : 12비트 할당. 각 서버에는 ID를 생성할 때마다 일련번호를 1씩 증가시킨다. 이 값은 1밀리초가 경과할 때 마다 0으로 초기화(reset) 된다.


#### 결론

**트위터 스노우플레이크(twitter snowflake) 채택**


### 3단계 - 상세 설계

#### 타임스탬프
트위터 스노우플레이크 적용을 했다고 할 때, 가장 중요한 41비트를 차지하고 있음

시간 순으로 정렬 가능(타임스템프는 시간에 따라 점점 큰 값을 가지게 됨)

```
41비트로 표현될 수 있는 타임스탬프의 최대값
==  2^41 - 1 = 2199023255551 밀리초
~ 대략 69년 동안 정상 동작
```

**단점?**   
69년이 지나면, 기원 시각을 바꾸거나, ID체계를 다른것으로 이전해야한다.

#### 일련 번호

12비트, 2^12 =  4096개의 값을 가질 수 있음   
어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.

### 4단계 - 마무리

#### 추가로 논의하면 좋을 것들

**시계 동기화(clock synchronization):**   

- ID 생성 서버들이 전부 같은 시계를 사용한다고 가정.    
하지만, 이런 가정은 **하나의 서버가 여러 코어에서 실행 될 경우**, 유효하지 않을 수 있다.   
- 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우에도 마찬가지
- NTP(Network Time Protocol) : 시계 동기화 문제를 해결하는 가장 보편적인 수단.


**각 절(section)의 길이 최적화:**

- 동시성(concurrency)이 낮고, 수명이 긴 애플리케이션이라면 일련 번호 절의 길이를 줄이고, 타임스탬프 절의 길이를 늘리는 것이 효과적일 수도 있다.

**고 가용성(high availability):**   

- ID 생성기는 필수 불가결(mission critical) 컴포넌트, 높은 가용성을 제공해야 한다.



## Note - 추가로 조사하면 좋은 것들(2024-03-27 부터)

1.  시계 동기화 문제를 해결하는 솔루션을 조사해보자
2.  ID 생성기의 높은 가용성을 제공하는 여러 솔루션을 조사해보자
3. 경매 시스템에서는 짧은 찰나의 순간을 캐치하기 위해서 어떤 ID 전략을 사용해야 할까?
