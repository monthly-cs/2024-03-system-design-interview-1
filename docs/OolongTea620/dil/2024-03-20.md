# 6장 키-값 저장소 설계

## 시스템 컴포넌트 

### 일관성(consistency)

**정족수 합의 프로토콜**

데이터 일관성을 보장해주기 위한 노드간 동기화 프로토콜

#### 정의

N : 사본 개수   
W : 쓰기 연산에 대한 정속수 (**적어도 W개의 서버로부터** 쓰기 연산이 성공했다는 **응답이 있어야** 한다)   
R : 일긱 연산에 대한 정족수 (적어도 R개의 서버로부터 응답을 받아야 한다)


#### 예시      
W = 1 의 의미
- 쓰기 연산이 성공했다고 판단하기 위해서 중재자는 최소 한대 서버로부터 응답을 받아야 한다.
```
❗중재자는 클라이언트와 노드 사이의 프록시(Proxy)역할을 한다.
```


#### 일관성의 경우

**W + R > N 인 경우**   
**강한 일관성(Strong consistency)** :  
강한 일관성 보장   
일관성을 보장할 최신데이터를 가진 노드가 최소 1개는 겹친다.

**R = 1, W = N** :   
빠른 읽기 연산에 최적화된 시스템

**W = 1, R = N** :   
빠른 쓰기 연산에 최적화된 시스템

**W + R <= N** :   
강한 일관성이 보장되지 않음

요구되는 일관성 수준에 따라서 W, R, N을 바꾸면 된다.

#### 일관성 모델 (consistency model)

- 키-값 저장소를 설계할 때, 고려해야할 또 하나의 중요한 요소
- 일관성의 수준을 결정한다.

 **종류**

- 강한 일관성(Strong consistency) : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환
    - 클라이언트는 절대로 낡은 데이터를 알지 못한다.
    - 고가용성 시스템에 적합하지 않다(새로운 요청의 처리가 중단되기 때문)
    ```
    모든 사본에 현재 쓰기 연산의 결과가 반영될 때 까지 
    해당 데이터에 대한 읽기/쓰기를 금지한다.
    ```

- 약한 일관성(Weak consistency) : 읽기 연산은 가장 최근에 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.

- 최종 일관성(Eventual consistency) : 약한 일관성의 한 형태로, 갱신결과가 결국에는 모든 사본에 반영(동기화)되는 모델이다.
    - 다이나모, 카산드라 저장소
    - 병렬적인 쓰기 연산이 일어나면, 일관성이 깨질 수 있다.
    - 해당 문제를 클라이언트가 해결해야 한다.
        - 클라이언트에서 데이터 버전 정보를 활용하여 일관성이 깨진 데이터를 읽지 않도록 해아한다.

### 비 일관성 해소 기법: 데이터 버저닝

**요약**
- 데이터 다중화 : 가용성은 높어지지만, 사본 간 일간성이 깨질 가능성이 올라간다.

- 데이터 비일관을 해소할 때, 버저닝(versioning), 벡터 시계(vector clock)을 이용 할 수 있다.


#### 데이터 일관성이 깨지는 과정
데이터 동시성의 문제


#### 버저닝
데이터를 변경할 때 마다, 해당 데이터의 새로운 버전을 만드는 것.   
각 버전의 데이터는 변경 불가능이다.

#### 벡터 시계
[서버, 버전]의 순서쌍을 데이터에 매단 것.   
어떤 버전이 선행 버전인지, 후행 버전인지, 아니면 다른 버전과 충돌이 있는지 판별하기 위해 사용한다.

-> 내일 이어서
