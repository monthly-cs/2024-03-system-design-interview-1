---
marp: true
paginate: true
backgroundColor: #000
color: #fff
---

# 08. URL 단축기 설계

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true, theme: 'dark' });
</script>

---

# 1단계. 문제 이해 및 설계 범위 확정

- 요구사항
  - URL 단축: 주어진 긴 URL을 훨씬 짧게 줄인다
  - URL 리디렉션: 축약된 URL로 HTTP 요청이 오면, 원래 URL로 안내
  - 높은 가용성과 규모 확장성, 그리고 장애 감내가 요구
- 개략적 추정
  - 쓰기 연산: 매일 1억개 생성. 초당 1160(= 1억 / 24 / 3600)
  - 읽기 연산: 읽기:쓰기는 10:1 이라고 가정. 초당 읽기연산 11,600
  - 보관할 레코드: 10년간 운영한다고 가정시 3650억개
  - 축약전 URL 평균 길이는 100이라고 가정
  - 10년동안 필요한 저장 용량 = 36.5TB

---

# 2단계: 개략적인 설계안 제시 및 동의 구하기

---

## API 엔드포인트

- 단축용 엔드포인트
  - 새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL 를 인자로, POST 요청을 보내야
- URL 리디렉션용 엔드포인트
  - 단축 URL에 대해 HTTP 요청이 오면, 원래 URL로 보내주는 용도의 엔드포인트

---

## URL 리디렉션

- 301 Permantely Moved
  - 해당 URL에 대한 HTTP 요청의 처리책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답
  - 영구적으로 이전되었으므로, 브라우저는 이 응답을 캐시
  - 서버 부하를 줄이는 장점
- 302 Found
  - 주어진 URL로의 요청이 일시적으로 Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답
  - 클라이언트의 요청은 언제나 단축 URL 서버에 먼저 보내진 이후에, 원래 URL 로 리디렉션 되어야
  - 트래픽 분석이 중요할 때

---

## URL 단축

- 해시 함수
  - 긴 URL을 해시값으로 대응시킬 함수
  - 입력으로 주어지는 긴 URL이 다른 값이면, 해시 값도 달라야
  - 계산된 해시값은 원래 입력된 긴 URL로 복원될 수 있어야

---

# 3단계: 상세 설계

---

## 데이터 모델

- 모든 것을 해시테이블에 두는 것은, 실제 시스템에 쓰기에는 곤란
  - 메모리는 유한하고, 비쌈
- <단축 URL, 원래 URL>의 순서쌍을 DB에 저장ㅈ하는 것이 좋다

---

## 해시 함수

- 원래 URL 를 단축 URL로 변환
- 해시 값 길이
  - [0-9, a-z, A-Z]로 구성. 62개 문자 사용 가능. (62^n) >= 3650억인 n의 최솟값을 찾아야. n = 7
- 해시 함수 구현 방법
  - 해시 후 충돌 해소
  - base-62 변환

---

### 해시 후 충돌 해소

- 해시함수를 이용하면, 길이가 7보다 길다.
- 앞의 7글자로 자르면, 해시 결과가 충돌할 확률이 높아짐
- 블룸필터를 이용해, 충돌시 질의할 때 성능을 높일 수 있음.
- 단축 URL 길이 고정
- ID 생성기 불필요
- 해소 전략 필요
- 다음에 쓸 수 있는 URL을 알아내는 것이 불가능

---

### base-62 변환

- 진법 변환은 URL 단축키 구현시 흔히 사용. 사용 가능 문자 갯수가 62개여서, 62진법
- 수의 표현 방식이 다른 두 시스템이 같은 수를 공유해야 할 때 사용
- ID를 62진법으로 변환
- 단축 URL의 길이가 가변적.
- 유일성 보장 ID 생성기가 필요.
- 충돌은 불가능. ID의 유일성이 보장되어야 적용 가능한 전략이기 때문
- 다음에 쓸 수 있는 URL이 무엇인지 유추 가능. 보안상 문제될 소지

---

## URL 단축시 상세 설계

<div class='mermaid'>
flowchart LR
  1[1. 입력: longURL]
  2[2. 입력된 URL이 DB에 있나?]
  3[3. DB에서 찾은 단축 URL 반환]
  4[4. 새로운 ID 생성]
  5[5. 생성된 ID를 단축 URL로 변환]
  6[6. ID, 단축 URL, 원래 URL을 DB에 저장]
  1 --> 2
  2 --> |예| 3
  2 --> |아니오| 4
  4 --> 5
  5 --> 6
</div>

---

## URL 리디렉션 상세 설계

<div class='mermaid'>
flowchart LR
  사용자 --> |1 단축 URL 조회| 로드밸런서
  로드밸런서 --> 웹서버
  웹서버 --> 캐시
  웹서버 --> DB
  로드밸런서 --> |5 원래 URL 반환| 사용자
</div>

---

# 4단계: 마무리

- 추가 논의
  - 처리율 제한 장치: 단축 URL 시스템은 많은 단축 요청이 밀려들 경우 무력화될 수 있음.
  - 웹 서버의 규모 확장: 무상태 계층으로 설계하면, 웹서버의 자유로운 증설/삭제가 가능
  - 데이터베이스의 규모 확장: 데이터베이스의 다중화/샤딩을 통해 규모확장성 달성 가능
  - 데이터 분석 솔루션: URL 단축기에 분석 솔루션을 통합해두면, 중요정보 추적 가능
  - 가용성, 데이터 일관성, 안정성: 대규모 시스템의 성공적 운영을 위해 반드시 갖추어야 함
